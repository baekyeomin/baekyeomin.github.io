---
title: "[Algorithm] 알고리즘의 시간복잡도 (Big-O notation) "
categories: [CS, Algorithms]
layout: single
toc : true
toc_sticky: true
comments: true
---

<[프로그래머스] 알고리즘 완전정복 캠프 - Python> 에 참여하여 공부한 기록입니다. 
{: .notice--info}

## 시간 복잡도
- <u>문제의 크기</u>와 이를 해결하는데 걸리는 <u>시간</u> 사이의 관계

## 공간 복잡도
- <u>문제의 크기</u>와 이를 해결하는데 필요한 <u>메모리 공간</u> 사이의 관계

## Big-O Notation
- 점근표기법 (asymptotic notation) 中 하나
- 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현
ex. 입력의 크기가 n 일 때, <br> O(n) :  입력의 크기에 비례하는 시간 소요 <br> O(logn) : 입력의 크기의 로그에 비례하는 시간 소요

| 시간 복잡도         | 예시 알고리즘        | Best Case      | Worst Case     | 비고                                               |
|---------------------|----------------------|----------------|----------------|----------------------------------------------------|
| \(O(n)\)            | 최대값 찾기          | \(O(n)\)       | \(O(n)\)       | 끝까지 다 살펴보기 전에는 최대값을 알 수 없음     |
| \(O(\log n)\)       | 이진 탐색            | \(O(1)\)       | \(O(\log n)\)  | 정렬된 데이터에서만 가능, 반씩 나누며 탐색        |
| \(O(n^2)\)          | 삽입 정렬            | \(O(n)\)       | \(O(n^2)\)     | 거의 정렬된 경우 빠름, 역순일수록 느림            |
| \(O(n \log n)\)     | 병합 정렬            | \(O(n \log n)\)| \(O(n \log n)\)| 모든 경우에서 안정적인 성능, 정렬 알고리즘의 하한 |


## QUIZ
### 📍병합 정렬의 복잡도
 N 개의 원소로 이루어진 배열이 있습니다. 이 배열을 반씩 나누어 각각 정렬한 뒤 병합 (merge) 하는 방법을 통해서, 소위 "divide-and-conquer" 방법으로 정렬할 수 있습니다. 이러한 방법으로 데이터를 정렬하는 알고리즘을 병합 정렬 (merge sort) 알고리즘이라고 부릅니다. 병합 정렬 알고리즘의 복잡도를 big-O 점근 표기법으로 표기하면?
**[정답]** O(nlogn)

### 📍이진 탐색 알고리즘의 복잡도
이미 크기 순으로 정렬되어 있는 N 개의 원소를 가지는 배열로부터, 입력으로 주어진 데이터가 배열 내에 존재하는지, 또한 존재한다면 몇 번째 원소인지를 탐색하는 방법으로서, 배열의 가운데 원소와 입력 데이터를 비교하고 그 데이터와 같은 원소가 존재할 수 없는 절반의 배열을 버리는 방식을 택할 수 있습니다. 이러한 탐색 방법을 이진 탐색 (binary search) 이라고 부릅니다. 이진 탐색 알고리즘의 복잡도를 big-O 점근 표기법으로 표기하면?
**[정답]** O(logn)

### 📍선형 탐색 알고리즘의 복잡도
N 개의 원소가 무작위 순서로 늘어서 있는 배열 내에, 입력으로 주어진 데이터가 존재하는지, 그리고 존재한다면 몇 번째 위치에 존재하는지를 알아내기 위하여 배열을 처음부터 시작해서 원소를 하나씩 입력 데이터와 비교하는 방법을 적용할 수 있습니다. 이러한 탐색 방법을 선형 탐색 (linear search) 이라고 부릅니다. 선형 탐색 알고리즘의 복잡도를 big-O 점근 표기법으로 표기하면?
**[정답]** O(n)

### 📍모든 원소 사이의 대소 관계 비교 알고리즘의 복잡도
N 개의 수가 입력으로 주어진다고 할 때, 모든 원소들 사이의 대소 관계를 비교하여 N X N 행렬로 나타내고자 합니다. 이 문제를 풀기 위하여 모든 원소의 쌍에 대하여 대소 관계를 비교하여 그것을 행렬에 채우는 방법을 택한다고 할 때, 이 알고리즘의 복잡도를 big-O 점근 표기법으로 표기하면?
**[정답]** O(n^2)

### 📍행렬 곱셈 알고리즘의 복잡도
N 행 N 열의 정사각행렬 A 와 B 가 주어진다고 할 때, 이 두 행렬의 곱 (product) 인 N X N 행렬 C 를 계산하기 위하여 다음과 같은 방법을 쓸 수 있습니다.

```python
for i in range(N):
    for j in range(N):
        C[i][j] = 0
        for k in range(N):
            C[i][j] += A[i][k] * B[k][j]
```

이러한 알고리즘을 이용하여 행렬의 곱셈을 행할 때, 이 행렬 곱셈 (matrix multiplicaiton) 알고리즘의 복잡도를 big-O 점근 표기법으로 알맞게 표기하면?
**[정답]** O(n^3)