---
title: "[Paper Review] Matrix Factorization Techniques for Recommender Systems"
categories: [Activities, Recommender Systems]
tags:
  - AI
  - Recommender Systems
layout: single
toc : true
toc_sticky: true
comments: true
use_math: true
---

**Matrix Factorization Techniques for Recommender Systems**  
(Yehuda Koren, Robert Bell, Chris Volinsky, IEEE Computer, 2009)
{: .notice--info}

## 0. 이 논문에 대하여..
본 논문은 PrecS Lab에서 두 번째로 읽게 된 논문입니다. <br>
NN (Nearest Neighbor) 방법보다 우수하다는 행렬 분해 모델을 소개하는 논문이었으며, 해당 모델은 Netflix Prize 대회에서 입증되었듯이 Implicit feedback, temporal effects, confidence levels와 같은 추가적인 정보를 모델에 포함시킬 수 있게 해주는 모델입니다. <br> <br> <br>

## 1. 서론
오늘날 소비자들에게는 수많은 선택지가 주어집니다. <br>
온라인 쇼핑몰이나 OTT 등과 같은 서비스들은 엄청 다양한 상품들을 제공하고 있어서, 각 사용자의 취향이나 니즈를 만족시키는, <span style="color: blue">**딱 맞는 상품을 사용자와 연결시켜주는 것**</span>이 사용자 만족도와 충성도를 높이는 데 매우 중요해졌습니다. <br> <br>
이런 이유로 아마존이나 넷플릭스 같은 많은 기업들이 추천시스템에 관심을 가지게 되었는데, 추천시스템이란 사용자가 어떤 상품에 관심을 보이는지 패턴을 분석해서 취향에 맞는 더 <span style="color: blue">개인화된 추천</span>을 제공하는 기술입니다. <br> (제가 소속되어 있는 PrecS 랩도 **Personalized** Recommender System 의 약자입니다.) <br>
특히 이런 추천 시스템은 영화, 음악, TV 쇼 같은 엔터테인먼트 콘텐츠에서 더 유용하다고 합니다. <br> <br>
더욱이 영화 같은 경우에는 여러 사람이 같은 영화를 보기도 하고, 한 사람이 여러 영화를 보기도 하며 사용자들은 영화에 대한 만족도를 직접 평가(rating)하기 때문에 영화가 누구에게 잘 맞는지에 대한 데이터가 엄청 많이 쌓일 수 있습니다. 기업들이 이렇게 많이 쌓인 데이터를 분석해서 각 사용자에게 볼 만한 영화를 추천해줄 수 있게 됩니다. <br> <br>

## 2. Recommender System Strategies
(바로 전에 읽은 논문 내용을 간추려서 담은 문단)
크게 보면 추천시스템은 CB와 CF 방법이 있습니다. <br>

### 🐾 CB (Content Based) 방법 <br>
각 사용자나 각 상품의 특성을 설명하는 profile을 만듭니다. <br>
예를들어 영화 같은 경우, 장르, 출연 배우, 흥행 정도 등의 정보가 영화 프로필(이전 논문에서의 표현 : item profile)에 포함될 수 있습니다. <br>
이러한 프로필을 이용해 추천시스템은 사용자와 잘 맞는 상품을 연결해줍니다. <br>
물론, CB 방식은 외부 정보를 수집해야하는데, 이 정보가 항상 수집하기 쉬운 것은 아니기 때문에 어려움이 있습니다. <br>
CB의 대표적인 성공 사례로는 <span style="color: blue"> Music Genome Project </span>이 있습니다. <br>

음악 게놈 프로젝트가 무엇인지: <https://en.wikipedia.org/wiki/Music_Genome_Project>

이는 인터넷 라디오 서비스 pandora.com에서 사용되는 기술이라고 합니다. <br>
이 프로젝트에서는 음악 분석가가 수백가지 음악적 특성을 기준으로 각 곡을 평가하고, 이러한 속성들(Genome, 유전자?라고 표현?)은 단순히 곡의 음악적 특징 뿐만 아니라 듣는이의 음악적인 선호도까지 반영합니다. <br> <br>

### 🐾 CF(Collaborative Filtering) 방법 <br>
CF 방법은 과거 사용자의 행동 (rating이나 구매이력.. 등)만을 이용하고 explicit profile은 만들지 않는 방법입니다. <br>
CF는 최초의 추천 시스템인 Tapestry의 개발자들이 만든 말이라고 합니다.
<br> CF는 사용자들 사이의 관계와 상품들 사이의 관련성을 분석해서 새로운 사용자-아이템 연결을 찾아냅니다. <br>
CF의 가장 큰 장점은 <span style="background-color: #fff3cd">특정 분야에 종속되지 않는 domain free방식이라는 점</span> 과, <span style="background-color: #fff3cd">CB 방법만으로는 파악하기 어려운 데이터 특성도 다룰 수 있다는 점</span> 입니다. <br>
일반적으로는 CB보다 CF가 더 정확하지만, 새로운 사용자나 새로운 상품에 대해서는 추천이 어려운 
cold start problem이 존재하는 방법이기에 어떤 경우에서는 CB가 더 유용합니다. <br>

또, CF는 다시 **이웃 기반 방법(neighborhood methods)**과 **잠재 요인 모델(latent factor models)**로 나뉩니다. <br>

#### 이웃 기반 방법 (neighborhood methods)
이 방법은 다시 Item-based와 User-based로 나뉩니다. <br>
**Item based**는 사용자가 좋은 평점을 매긴 영화와 "비슷한 영화끼리" 묶어서 추천하는 방식이고, **User based**는 취향이 사용자와 비슷한 사람들을 찾아서 추천하는 방식입니다. <br>
예를들어 어떤 사용자가 라이언 일병 구하기라는 영화를 아직 보지 않았다고 하겠습니다. <br>
시스템은 먼저 해당 영화와 비슷한 영화를 찾을 건데, 이때 비슷하다는 것은 같은 사람들이 비슷한 점수를 준 영화들을 의미합니다. <br> 
<u>여기서 같다란?</u> <br>
CF는 CB와 달리 인구 통계 정보를 쓰지 않습니다. 그래서 같다는것이 뭐 같은 여성인 사용자, 같은 나잇대의 사용자... 이런게 아니라 해리포터를 똑같이 좋아한 사람, 아니면 인터스텔라를 싫어한 사람.. 뭐 이런 느낌으로 이해하세용 <br>
라이언 일병 구하기 같은 경우 전쟁영화, 스필버그 감독의 영화, 톰행크스가 출연한 영화 등이 이웃 영화(=비슷한 영화)로 뽑힐 것입니다. <br> 이제 그 사용자가 이미 본 영화들 중에서 이 이웃 영화들 평점을 확인합니다. <br>
무슨 말이냐면, 만약 그 사용자가 전쟁 영화들을 모두 높게 평가했다면? -> 라이언 일병 구하기도 높게 평가할 확률이 높다! <br>

반면에 **user oriented** 방식은 아래 그림과 함께 설명하겠습니다. 

![Computer09](/assets/images/computer05_figure1.png) 

나랑 취향이 비슷한 사람들을 찾아서, 그 사람들이 좋아한 영화를 추천하는 것이 user oriented 방식입니다. <br> 

그림에서는 joe가 왼쪽의 3개 영화를 좋아하고, 시스템은 **joe와 같은 영화들을 좋아한 다른 사람들을 찾습니다.** 그 후 그 사람들이 공통으로 좋아한 영화가 무엇인지를 확인합니다. <br> 그 결과 그 사람들이 전부 좋아한 라이언 일병 구하기는 1순위로, 듄은 2순위로 추천이 될 것입니다. <br> 저도 듄 보고싶습니다. 블로깅 마치면 백준 풀고 듄 보다 잘 것입니다. 히히
<br> <br>

#### 잠재 요인 모델(latent factor models)
또 다른 방법인 <span style="color: blue">잠재 요인 모델(latent factor model)</span>은 평점 패턴으로부터 추론된 약 20~100개의 요인들을 이용해 사용자와 아이템을 동시에 설명하려고 하는 방법입니다. <br> 이러한 요인들은 코미디, 드라마, 액션, 아동 대상 여부 같은 명확한 특성일 수도 있지만 캐릭터의 깊이감이나 독특함 같은 모호한 특성일 수도 있습니다. 각 사용자에 대해, 각 요인은 해당 특성이 강한 영화를 얼마나 좋아하는지를 나타냅니다. <br> 
예를 들어 2개의 차원을 "여성 취향 - 남성 취향" 과 "진지함 - 코미디"로 가정한 그림은 다음과 같습니다. 

![Computer09](/assets/images/computer05_figure1.png) 

male versus female 축과 serious versus escapist 축으로 이루어진 평면 위에 몇몇 영화와 가상의 사용자들이 배치되어있는 그림입니다. <br> 
이 모델에서는 어떤 사용자의 영화 예상 rating이 (영화 평균 평점 대비) 사용자 위치 벡터와 영화 위치 벡터의 **내적**으로 계산됩니다. <br> 예를 들어 Gus는 Dumb and Dumber를 매우 좋아하고, The Color Purple은 싫어하며, Braveheart는 평균 정도로 평가할 것으로 예상됩니다. 또한 Ocean’s 11 같은 영화나 Dave 같은 사용자는 이 두 차원에서 비교적 중간에 위치한 것을 확인할 수 있습니다. 

위 내용을 정리하면 아래와 같습니다. 
(제가 발표용으로 만든 피피티 중 일부입니다.)

![Computer09](/assets/images/02ppt1.png)

## 3. Matrix Factorization Methods
Latent Factor Model의 가장 성공적인 구현 방식 중 하나는 **행렬분해 (matrix factorization)**입니다. <br>
행렬 분해는 item rating 패턴으로부터 추론된 factor vector(요인 벡터)를 이용해 사용자와 아이템을 동시에 표현한다고 합니다. <br>
그리고 사용자 요인과 아이템 요인이 유사할수록 해당 아이템이 해당 사용자에게 추천된다고 합니다. <br>
이러한 방법은 좋은 확장성(scalability)과 높은 예측 정확도, 다양한 실제 상황을 모델링할 수 있는 높은 유연성이라는 장점을 가지고 있다고 합니다. 따라서 (논문기준) 최근 들어 널리 사용되고 있다고 합니다. <br> <br>
추천 시스템은 다양한 형태의 입력 데이터를 사용하는데, 이 데이터는 보통 한 축은 사용자, 다른 한 축은 아이템을 나타내는 행렬 형태로 표현됩니다. <br>
가장 다루기 쉬운 데이터는 사용자가 자신의 선호를 직접 표현한 <span style="background-color: #fff3cd">explicit feedback 데이터(rating)</span> 입니다. 예를 들어 Netflix는 영화에 대한 rating을 수집하고, TiVo 사용자는 TV 프로그램에 대해 ‘좋아요/싫어요’ 버튼을 눌러 선호를 표시합니다. 이런 명시적인 피드백 (explicit feedback)을 이전 논문에서는 rating이라고 표현했습니다. 이런 explicit feedback 행렬은 <span style="background-color: #fff3cd">sparsity</span> 문제가 존재합니다. <br>
<span style="color: red">행렬 분해의 장점 중 하나는 explicit feedback 행렬이 희소 행렬인 경우 추가적인 정보(implicit feedback)도 함께 이용해서 추천할 수 있다는 점입니다. </span> <br>
구매 이력, 검색 기록, 마우스 움직임 등과 같은 사용자 행동을 관찰해서 간접적으로 선호를 파악하는 방식이 implicit feedback(암묵적 피드백)입니다. <br> 이는 보통 어떤 행동의 발생 여부(있음/없음)를 나타내기 때문에 보다 더 dense matrix로 표현됩니다. 

## 4. A Basic Matrix Factorization Model
행렬 분해 모델은 user 와 item을 공통된 잠재 요인 공간(latent factor space, 차원 수 f)으로 매핑하고, 그 공간에서 **내적**을 통해 item-user의 관계를 모델링합니다. <br>
즉 각 아이템 i는 $q_i \in \mathbb{R}^f$ 로, 각 사용자 u는 $p_u \in \mathbb{R}^f$ 로 표현됩니다. <br>
특정 아이템 i에 대해 $q_i$ 의 각 원소는 그 아이템이 해당 factor를 얼마나 많이 가지고 있는지는 나타내며, 값은 양수 또는 음수가 될 수 있습니다. <br>
또, 특정 사용자 u에 대해 $p_u$ 의 각 원소는 해당 factor 가 강한 아이템에 대해 사용자가 얼마나 관심을 가지는지를 나타내며, 이 또한 양수 또는 음수가 될 수 있다. <br>
두 벡터의 내적 $q_i^{T} p_u$ 은 사용자 u와 아이템 i 사이의 interaction, 즉 아이템 특성 전반에 대한 사용자의 전체적인 선호도를 나타냅니다. <br>
사용자 u가 아이템 i에 부여할 평점 $r_{ui}$을 근사하는 예측값을 $\hat{r}_{ui}$라 하며, 식으로 표현하면 $\hat{r}_{ui} = q_i^{T} p_u$ 입니다. <br>
### 


## 쫑알 쫑알
앞부분에서 짧게 말했던 게놈 프로젝트.. <br>
고등학교 1학년 때인지 2학년 때인지 세본이라는 친구가 학종을 위한 프로젝트를 같이 하자고 하면서 언급했던 건데.. <br> 저는 그때 당시 정말 1도 모르는 상태였기에 .. 그게 머란 하고 흐지부지 되었었는데 걔는 어떻게 이런걸 알고 있었던 것일까요..?? <br> 심지어 컴공도 아니고 메디컬을 희망하던 친구인ㄷ..?<br> 저도 요런 상식? 잡지식?이 풍부했으면 좋겠네요