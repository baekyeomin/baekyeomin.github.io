---
title: "[BOJ 10844] 쉬운 계단 수 (python)"
categories: [BaekJoon,Silver]
tags:
  - Python
  - 다이나믹 프로그래밍
layout: single
toc : true
toc_sticky: true
comments: true
---

## 1. 문제
> 문제 링크 | <https://www.acmicpc.net/problem/10844>
> 티어 | **Silver1**
> 알고리즘 분류 | **다이나믹 프로그래밍**

## 2. 문제 분석
#### 🐾 생각 흐름 (1차시도-시간초과) 
n(정수)을 입력받고, n의 각자리수(문자)를 담은 list를 만들었다. <br>
n=100이라면 [1,0,0]을 만드는 것이다. <br>
count는 계단수 개수 저장용 변수다 <br>
1자리 계단수는 1~9로 총 9개라서 바로 9로 두었다. <br>
n이 2 이상일 때는 n자리 수를 하나씩 순회하면서 n=2면 10~99, n=3이면 100~999 범위에서 각 숫자가 “계단수인지” 검사하도록 한다. <br>
계단수면 count가 1 증가한다.<br>
이후 문제 요구대로 마지막 출력은 1000000000로 나눈 나머지로 한다.


```python
n = int(input())
lst = [int(i) for i in str(n)]
count = 0

if n == 1 : 
    count = 9
    
elif n != 1 :
    for i in range(10**(n-1), 10**n) : 
        lst = [int(j) for j in str(i)]
        cnt = 0
        ok = True
        for k in range(len(lst)-1): 
            if abs(lst[k] - lst[k+1]) != 1:
                ok = False
                break
            else :
                cnt += 1
                
        if cnt == n-1 :
            count += 1
        else : 
            continue
        
print(count%1000000000)
    
```
브루트포스로 풀려고 했고, VS에서는 잘 돌아갔었다. <br>
그런데 시간 초과가 떴다. 😭 <br>
<span style="color:red;">n이 너무 크거나, 최대, 최소, 개수, 경우의 수 등을 구할 때 등 </span> 은 dp를 쓰는게 더 나은지 의심해볼 필요가 있다는 것을 알게되었다. 


#### 🐾 생각 흐름 (2차시도-맞았습니다) 
1. 길이가 length이고 마지막 숫자가 num인 계단수 개수를 2차원 배열을 생성한다.
2. 길이 = 1일 때는 가능한 계단 수가 1...9이기에 for i in range(1,10) : dp[1][i] = 1 을 적었다.
3. 두 자릿수 이상의 수에서 마지막 자리가 0이나 9인 경우, 계단수가 되려면 각각 앞자리가 1 또는 8인 경우(…10, …89)만 가능하다. 반면 마지막 자리가 1부터 8 사이인 경우에는 앞자리가 d-1 또는 d+1인 두 가지 경우가 모두 가능하다.
4. 따라서 점화식 : dp[L][d] = dp[L-1][d-1] + dp[L-1][d+1]

```python
n = int(input())
dp = [[0]*10 for _ in range(n+1)]

for i in range(1,10) :
    dp[1][i] = 1


for length in range (2,n+1) :
    for num in range(10) :
        if num == 0 :
            dp[length][num] = dp[length-1][1]
        elif num == 9 :
            dp[length][num] = dp[length-1][8]
        else :
            dp[length][num] = dp[length-1][num-1] + dp[length-1][num+1]
        
        
answer = sum(dp[n])
print(answer % 1000000000)
```

계단수를 찾아라였으면 브루트포스도 괜찮았겠지만 개수를 구하는 문제였기에 dp가 더 나은 선택이었다.

## 3. 쫑알쫑알
과동아리(KOSS)에서 백준 대회를 한다기에 1일 1백준을 하고 블로깅을하기로 했다. <br>
많이풀수록 높은점수를 얻고, 순위에 따라 상품을 타는 대회인데.. 브론즈 5문제 1점.. 골드 5문제 3점.. 아무리봐도 상품을 위해서는 브론즈문제만 주구장창 푸는게 이득이지만 실력향상을 위해 그러지는 않기로 했다. <br>
누구야...점수 저렇게 정한사람..

<br>

    개인 공부 기록용 블로그입니다.
    오류나 틀린 부분이 있을 경우 언제든지 글이나 메일로 지적해주시면 감사하겠습니다! ☺

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}